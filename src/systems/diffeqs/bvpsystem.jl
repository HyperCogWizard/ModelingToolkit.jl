"""
$(TYPEDEF)

A system of ordinary differential equations.

# Fields
$(FIELDS)

# Example

```julia
using ModelingToolkit
using ModelingToolkit: t_nounits as t, D_nounits as D

@parameters σ ρ β
@variables x(t) y(t) z(t)

eqs = [D(x) ~ σ*(y-x),
       D(y) ~ x*(ρ-z)-y,
       D(z) ~ x*y - β*z]

@named de = ODESystem(eqs,t,[x,y,z],[σ,ρ,β],tspan=(0, 1000.0))
```
"""
struct ODESystem <: AbstractODESystem
    """
    A tag for the system. If two systems have the same tag, then they are
    structurally identical.
    """
    tag::UInt
    """The ODEs defining the system."""
    eqs::Vector{Equation}
    """Independent variable."""
    iv::BasicSymbolic{Real}
    """
    Dependent (unknown) variables. Must not contain the independent variable.

    N.B.: If `torn_matching !== nothing`, this includes all variables. Actual
    ODE unknowns are determined by the `SelectedState()` entries in `torn_matching`.
    """
    unknowns::Vector
    """Parameter variables. Must not contain the independent variable."""
    ps::Vector
    """Time span."""
    tspan::Union{NTuple{2, Any}, Nothing}
    """Array variables."""
    var_to_name::Any
    """Control parameters (some subset of `ps`)."""
    ctrls::Vector
    """Observed variables."""
    observed::Vector{Equation}
    """
    Time-derivative matrix. Note: this field will not be defined until
    [`calculate_tgrad`](@ref) is called on the system.
    """
    tgrad::RefValue{Vector{Num}}
    """
    Jacobian matrix. Note: this field will not be defined until
    [`calculate_jacobian`](@ref) is called on the system.
    """
    jac::RefValue{Any}
    """
    Control Jacobian matrix. Note: this field will not be defined until
    [`calculate_control_jacobian`](@ref) is called on the system.
    """
    ctrl_jac::RefValue{Any}
    """
    Note: this field will not be defined until
    [`generate_factorized_W`](@ref) is called on the system.
    """
    Wfact::RefValue{Matrix{Num}}
    """
    Note: this field will not be defined until
    [`generate_factorized_W`](@ref) is called on the system.
    """
    Wfact_t::RefValue{Matrix{Num}}
    """
    The name of the system.
    """
    name::Symbol
    """
    A description of the system.
    """
    description::String
    """
    The internal systems. These are required to have unique names.
    """
    systems::Vector{ODESystem}
    """
    The default values to use when initial conditions and/or
    parameters are not supplied in `ODEProblem`.
    """
    defaults::Dict
    """
    The guesses to use as the initial conditions for the
    initialization system.
    """
    guesses::Dict
    """
    Tearing result specifying how to solve the system.
    """
    torn_matching::Union{Matching, Nothing}
    """
    The system for performing the initialization.
    """
    initializesystem::Union{Nothing, NonlinearSystem}
    """
    Extra equations to be enforced during the initialization sequence.
    """
    initialization_eqs::Vector{Equation}
    """
    The schedule for the code generation process.
    """
    schedule::Any
    """
    Type of the system.
    """
    connector_type::Any
    """
    Inject assignment statements before the evaluation of the RHS function.
    """
    preface::Any
    """
    A `Vector{SymbolicContinuousCallback}` that model events.
    The integrator will use root finding to guarantee that it steps at each zero crossing.
    """
    continuous_events::Vector{SymbolicContinuousCallback}
    """
    A `Vector{SymbolicDiscreteCallback}` that models events. Symbolic
    analog to `SciMLBase.DiscreteCallback` that executes an affect when a given condition is
    true at the end of an integration step.
    """
    discrete_events::Vector{SymbolicDiscreteCallback}
    """
    Topologically sorted parameter dependency equations, where all symbols are parameters and
    the LHS is a single parameter.
    """
    parameter_dependencies::Vector{Equation}
    """
    Metadata for the system, to be used by downstream packages.
    """
    metadata::Any
    """
    Metadata for MTK GUI.
    """
    gui_metadata::Union{Nothing, GUIMetadata}
    """
    A boolean indicating if the given `ODESystem` represents a system of DDEs.
    """
    is_dde::Bool
    """
    A list of points to provide to the solver as tstops. Uses the same syntax as discrete
    events.
    """
    tstops::Vector{Any}
    """
    Cache for intermediate tearing state.
    """
    tearing_state::Any
    """
    Substitutions generated by tearing.
    """
    substitutions::Any
    """
    If a model `sys` is complete, then `sys.x` no longer performs namespacing.
    """
    complete::Bool
    """
    Cached data for fast symbolic indexing.
    """
    index_cache::Union{Nothing, IndexCache}
    """
    A list of discrete subsystems.
    """
    discrete_subsystems::Any
    """
    A list of actual unknowns needed to be solved by solvers.
    """
    solved_unknowns::Union{Nothing, Vector{Any}}
    """
    A vector of vectors of indices for the split parameters.
    """
    split_idxs::Union{Nothing, Vector{Vector{Int}}}
    """
    The hierarchical parent system before simplification.
    """
    parent::Any

    function ODESystem(tag, deqs, iv, dvs, ps, tspan, var_to_name, ctrls, observed, tgrad,
            jac, ctrl_jac, Wfact, Wfact_t, name, description, systems, defaults, guesses,
            torn_matching, initializesystem, initialization_eqs, schedule,
            connector_type, preface, cevents,
            devents, parameter_dependencies,
            metadata = nothing, gui_metadata = nothing, is_dde = false,
            tstops = [], tearing_state = nothing,
            substitutions = nothing, complete = false, index_cache = nothing,
            discrete_subsystems = nothing, solved_unknowns = nothing,
            split_idxs = nothing, parent = nothing; checks::Union{Bool, Int} = true)
        if checks == true || (checks & CheckComponents) > 0
            check_independent_variables([iv])
            check_variables(dvs, iv)
            check_parameters(ps, iv)
            check_equations(deqs, iv)
            check_equations(equations(cevents), iv)
        end
        if checks == true || (checks & CheckUnits) > 0
            u = __get_unit_type(dvs, ps, iv)
            check_units(u, deqs)
        end
        new(tag, deqs, iv, dvs, ps, tspan, var_to_name, ctrls, observed, tgrad, jac,
            ctrl_jac, Wfact, Wfact_t, name, description, systems, defaults, guesses, torn_matching,
            initializesystem, initialization_eqs, schedule, connector_type, preface,
            cevents, devents, parameter_dependencies, metadata,
            gui_metadata, is_dde, tstops, tearing_state, substitutions, complete, index_cache,
            discrete_subsystems, solved_unknowns, split_idxs, parent)
    end
end
